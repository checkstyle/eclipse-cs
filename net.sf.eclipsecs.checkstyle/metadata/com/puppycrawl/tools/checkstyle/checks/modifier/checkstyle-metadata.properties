
ModifierOrder.desc = Checks that the order of modifiers conforms to the suggestions in the Java Language specification, sections 8.1.1, 8.3.1 and 8.4.3. The correct order is:\r\n<ol>\r\n<li>public</li>\r\n<li> protected</li>\r\n<li>private</li>\r\n<li>abstract</li>\r\n<li>static</li>\r\n<li>final</li>\r\n<li>transient</li>\r\n<li>volatile</li>\r\n<li>synchronized</li>\r\n<li>native</li>\r\n<li>strictfp</li>\r\n</ol>\r\n
ModifierOrder.name = Modifier Order

Modifiers.group = Modifiers

RedundantModifier.desc   = Checks for redundant modifiers in:\r\n<ol>\r\n<li>interface and annotation definitions,</li>\r\n<li>the final modifier on methods of final classes, and</li>\r\n<li>inner <code>interface</code> declarations that are declared as <code>static</code></li>\r\n</ol>\r\n<b>Rationale:</b> The Java Language Specification strongly discourages the usage of "public" and "abstract" for method declarations in interface definitions as a matter of style.<br/>\r\n<br/>\r\nVariables in interfaces and annotations are automatically public, static and final, so these modifiers are redundant as well.<br/>\r\n<br/>\r\nAs annotations are a form of interface, their fields are also automatically public, static and final just as their annotation fields are automatically public and abstract.<br/>\r\n<br/>\r\nFinal classes by definition can not be extended so the final modifier on the method of a final class is redundant.
RedundantModifier.name   = Redundant Modifier
RedundantModifier.tokens = Tokens to check.

InterfaceMemberImpliedModifier.name = Interface Member Implied Modifier
InterfaceMemberImpliedModifier.desc = Checks for implicit modifiers on interface members and nested types.<br/><br/>This check is effectively the opposite of RedundantModifier. It checks the modifiers on interface members, ensuring that certain modifiers are explicitly specified even though they are actually redundant.<br/><br/>Methods in interfaces are public by default, however from Java 9 they can also be private. This check provides the ability to enforce that public is explicitly coded and not implicitly added by the compiler.<br/><br/>From Java 8, there are three types of methods in interfaces - static methods marked with static, default methods marked with default and abstract methods which do not have to be marked with anything. From Java 9, there are also private methods marked with private. This check provides the ability to enforce that abstract is explicitly coded and not implicitly added by the compiler.<br/><br/>Fields in interfaces are always public static final and as such the compiler does not require these modifiers. This check provides the ability to enforce that these modifiers are explicitly coded and not implicitly added by the compiler.<br/><br/>Nested types within an interface are always public static and as such the compiler does not require the public static modifiers. This check provides the ability to enforce that the public and static modifiers are explicitly coded and not implicitly added by the compiler.
InterfaceMemberImpliedModifier.violateImpliedPublicField = Control whether to enforce that public is explicitly coded on interface fields.
InterfaceMemberImpliedModifier.violateImpliedStaticField = Control whether to enforce that static is explicitly coded on interface fields.
InterfaceMemberImpliedModifier.violateImpliedFinalField = Control whether to enforce that final is explicitly coded on interface fields.
InterfaceMemberImpliedModifier.violateImpliedPublicMethod = Control whether to enforce that public is explicitly coded on interface methods.
InterfaceMemberImpliedModifier.violateImpliedAbstractMethod = Control whether to enforce that abstract is explicitly coded on interface methods.
InterfaceMemberImpliedModifier.violateImpliedPublicNested = Control whether to enforce that public is explicitly coded on interface nested types.
InterfaceMemberImpliedModifier.violateImpliedStaticNested = Control whether to enforce that static is explicitly coded on interface nested types.

ClassMemberImpliedModifier.name = Class Member Implied Modifier
ClassMemberImpliedModifier.desc = Checks for implicit modifiers on nested types in classes.<br/>This check is effectively the opposite of RedundantModifier. It checks the modifiers on nested types in classes, ensuring that certain modifiers are explicitly specified even though they are actually redundant.<br/>Nested enums and interfaces within a class are always static and as such the compiler does not require the static modifier. This check provides the ability to enforce that the static modifier is explicitly coded and not implicitly added by the compiler.<p>Rationale for this check: Nested enums and interfaces are treated differently from nested classes as they are only allowed to be static. Developers should not need to remember this rule, and this check provides the means to enforce that the modifier is coded explicitly.</p>
ClassMemberImpliedModifier.violateImpliedStaticOnNestedEnum = Control whether to enforce that static is explicitly coded on nested enums in classes.
ClassMemberImpliedModifier.violateImpliedStaticOnNestedInterface = Control whether to enforce that static is explicitly coded on nested interfaces in classes.